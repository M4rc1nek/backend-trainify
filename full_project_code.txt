package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfig {

    private final UserRepository userRepository; // Wstrzykniƒôcie repozytorium u≈ºytkownik√≥w

    //Wczytywanie  u≈ºytkownika i zwracanie uzytkownika z zahashowanym haslem i rolami
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByEmail(username) // Spring Security u≈ºyje "username", ale u nas to jest email
                .map(user -> org.springframework.security.core.userdetails.User.builder() // Mapowanie (zamiana) naszej klasy User na UserDetails
                        .username(user.getEmail())
                        .password(user.getPassword())
                        // W prostym projekcie nie u≈ºywamy r√≥l, ale je≈õli chcesz, dodaj np. .roles("USER")
                        .build())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));
    }

    // 2. Provider uwierzytelniania, pobiera haslo od uzytkownika i prosi UserDetailsService o za≈Çadaowanie zahashowanego has≈Ça z bazy
    // A nastepnie prosi PasswordEncoder o sprawdzenie czy te dwa hasla do siebie pasuja (cos typu .matches)
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService()); // Ustawienie serwisu do ≈Çadowania u≈ºytkownika
        authProvider.setPasswordEncoder(passwordEncoder()); // Ustawienie kodera has≈Ça
        return authProvider;
    }

    // 3. Manager uwierzytelniania (Kieruje
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { // Uwierzytelnia uzytkownikow (np. sprawdzenie loginu, hasla)
        return config.getAuthenticationManager(); // zwraca w pe≈Çni skonfigurowany obiekt AuthenticationManager
    }

    // 4. Koder has≈Ça
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityFilterChainConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;


    //Polaczenie z frontendem
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }


    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        //W≈ÇƒÖczenie CORS i wy≈ÇƒÖczenie CSRF
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/register", "/login").permitAll() //register, /login ‚Üí dostƒôp dla wszystkich (nie trzeba tokena JWT).
                        .requestMatchers("/training/**").authenticated() //training/** ‚Üí dostƒôp tylko dla zalogowanych u≈ºytkownik√≥w (czyli muszƒÖ mieƒá wa≈ºny token JWT).
                        .anyRequest().authenticated()    //anyRequest().authenticated() ‚Üí ka≈ºde inne ≈ºƒÖdanie te≈º wymaga zalogowania.
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // ‚ÄûNie tw√≥rz sesji, nie zapamiƒôtuj zalogowanego u≈ºytkownika ‚Äî wszystko opiera siƒô na tokenie JWT"
                .authenticationProvider(authenticationProvider) // Mowi Springowi jak ma sprawdzac dane
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); // Wstaw m√≥j filtr JWT przed tym standardowym, ≈ºeby token by≈Ç sprawdzony, zanim Spring zacznie swoje logowanie

        return http.build();
    }
}
package com.trainify.trainifybackend.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
package com.trainify.trainifybackend.exception;

public class EmailAlreadyExistsException extends RuntimeException {
    public EmailAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public record ErrorResponseDTO(
        int status,      // kod HTTP (np. 400, 404, 500)
        String error,    // kr√≥tki opis b≈Çƒôdu (np. "Bad Request")
        String message,  // szczeg√≥≈Çowy komunikat (np. "Email jest ju≈º zajƒôty")
        String path,     // endpoint kt√≥ry wywo≈Ça≈Ç blƒÖd np ("/register")
        long timestamp   // czas w milisekundach od 01.01.1970 (Unix epoch), kiedy wyjƒÖtek wystƒÖpi≈Ç.,
        // Przyk≈Çad: 1734500000000 ‚Üí u≈Çatwia debugowanie i ≈õledzenie w logach
) {

    // Konstruktor u≈ÇatwiajƒÖcy ustawienie timestamp automatycznie
    public ErrorResponseDTO(int status, String error, String message, String path){
        this(status,error,message,path, System.currentTimeMillis());
    }
}
package com.trainify.trainifybackend.exception;


import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@Slf4j
@RestControllerAdvice // -> Dzia≈Ça globalnie na wszystkie kontrolery, zwraca JSON
public class GlobalExceptionHandler {


    /*
           CONFLICT (409) ‚Üí konflikt danych (np. email ju≈º istnieje)
           NOT_FOUND (404) ‚Üí brak danych (np. u≈ºytkownik nie istnieje)
           BAD_REQUEST (400) ‚Üí b≈Çƒôdne dane wej≈õciowe (np. niepoprawny format)
           UNAUTHORIZED (401) ‚Üí nieprawid≈Çowe logowanie lub brak autoryzacji


    webRequest.getDescription(false) - Pobiera opis ≈ºƒÖdania path, np.  /register lub /login
    Je≈õli dasz true, wynik zawiera≈Çby te≈º informacje o kliencie (np. IP, host)
     */

    @ExceptionHandler({EmailAlreadyExistsException.class, UsernameAlreadyExistsException.class})
    public ResponseEntity<ErrorResponseDTO> handleConflictExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.CONFLICT.value(),
                HttpStatus.CONFLICT.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }


    @ExceptionHandler({TrainingForUserNotFoundException.class, UserNotFoundException.class})
    public ResponseEntity<ErrorResponseDTO> handleNotFoundExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }


    @ExceptionHandler(WrongPasswordException.class)
    public ResponseEntity<ErrorResponseDTO> handleWrongPassword(WrongPasswordException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.UNAUTHORIZED.value(),
                HttpStatus.UNAUTHORIZED.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.UNAUTHORIZED);
    }


    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleAll(Exception exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd. Skontaktuj siƒô z administratorem.",
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }



}
package com.trainify.trainifybackend.exception;

public class TrainingForUserNotFoundException extends RuntimeException {
    public TrainingForUserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UsernameAlreadyExistsException extends RuntimeException {
    public UsernameAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class WrongPasswordException extends RuntimeException {
    public WrongPasswordException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {

    // üîë Tajny klucz do podpisywania token√≥w.
    // Powinien byƒá przechowywany w application.properties i byƒá silny (min. 256 bit, czyli 32 znaki base64).
    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    // ‚è± Czas wyga≈õniƒôcia tokena (np. 24 godziny)
    @Value("${application.security.jwt.expiration}")
    private long jwtExpiration;

    // --- Metody publiczne ---

    // 1. Ekstrakcja nazwy u≈ºytkownika (email) z tokena
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // 2. Generowanie tokena dla UserDetails (u≈ºytkownik)
    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    // 3. Sprawdzenie, czy token jest wa≈ºny dla danego u≈ºytkownika
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }


    // --- Metody prywatne (pomocnicze) ---

    // Ekstrakcja pojedynczej 'claims' (danych) z tokena
    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Generowanie tokena z dodatkowymi danymi ('extraClaims')
    private String generateToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails
    ) {
        return Jwts
                .builder() // Rozpoczƒôcie budowania tokena
                .setClaims(extraClaims) // Dodatkowe claims
                .setSubject(userDetails.getUsername()) // Temat (zazwyczaj nazwa u≈ºytkownika/email)
                .setIssuedAt(new Date(System.currentTimeMillis())) // Czas utworzenia
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration)) // Czas wyga≈õniƒôcia
                .signWith(getSignInKey(), SignatureAlgorithm.HS256) // Podpisanie kluczem SHA-256
                .compact(); // Zbudowanie i zwr√≥cenie jako String
    }

    // Sprawdzenie, czy token wygas≈Ç
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // Ekstrakcja daty wyga≈õniƒôcia
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Ekstrakcja wszystkich 'claims' (danych) z tokena
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder() // Uruchomienie parsera
                .setSigningKey(getSignInKey()) // U≈ºycie tajnego klucza
                .build()
                .parseClaimsJws(token) // Parsowanie tokena
                .getBody(); // Pobranie zawarto≈õci (claims)
    }

    // Pobranie tajnego klucza do podpisu
    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey); // Dekodowanie klucza z Base64
        return Keys.hmacShaKeyFor(keyBytes); // Zbudowanie klucza
    }
}
package com.trainify.trainifybackend.security;

import com.trainify.trainifybackend.security.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {  // OncePerRequestFilter ‚Äî zapewnia, ≈ºe filtr wykona siƒô tylko raz na ka≈ºde ≈ºƒÖdanie HTTP.

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain // Zbi√≥r filtr√≥w, przez kt√≥re ma przej≈õƒá ≈ºƒÖdanie
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization"); // Pobranie nag≈Ç√≥wka "Authorization", to tutaj frontend przesy≈Ça token JWT
        final String jwt;
        final String userEmail;

        // 1. Sprawdzenie, czy nag≈Ç√≥wek istnieje i zaczyna siƒô od "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra
            return;
        }

        jwt = authHeader.substring(7); // Obcina pierwsze 7 znak√≥w ("Bearer ") i zostawia sam token JWT. Przyk≈Çad:"Bearer abc.def.ghi" ‚Üí "abc.def.ghi"
        userEmail = jwtService.extractUsername(jwt); // U≈ºywa mojego JwtService zeby wyciagnac email uzytkownika (Bo w tokenie zapisuje jego adres email)

        // 2. Warunek sprawdzajacy czy token faktycznie zawiera email i czy nikt jeszcze nie jest zalogowany
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            // Wczytanie szczeg√≥≈Ç√≥w u≈ºytkownika (UserDetails) z bazy na podstawie emaila u≈ºytkownika
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);


            // 3. Sprawdza czy token JWT jest wa≈ºny i prawid≈Çowy
            //Jezeli token jest wazny i prawidlowy, tworzymy obiekt uwierzytelnienia ktory mowi "ten uzytkownik jest zalogowany"
            if (jwtService.isTokenValid(jwt, userDetails)) {

                // Tworzenie obiektu uwierzytelnienia Spring Security
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // JWT nie przechowuje has≈Ça, wiƒôc null
                        userDetails.getAuthorities() // Uprawnienia (role)
                );

                // Dodanie szczeg√≥≈Ç√≥w ≈ºƒÖdania do tokena (np. IP, sesja)
                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                // 4. Ustawia w globalnym kontek≈õcie Spring Security, ≈ºe ten u≈ºytkownik jest zalogowany (NAJWA≈ªNIEJSZA LINIA)
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra/kontrolera
    }
}
package com.trainify.trainifybackend.training.controller;


import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.service.TrainingService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class TrainingController {

    private final TrainingService trainingService;


    @PostMapping("/training")
    public ResponseEntity<TrainingDTO> addTrainingEndpoint(@RequestBody @Valid TrainingDTO trainingDTO) {
        return ResponseEntity.ok(trainingService.addTraining(trainingDTO));
    }


    @DeleteMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<Void> deleteTrainingEndpoint(@PathVariable Long trainingId, @PathVariable Long userId) {
        trainingService.deleteTraining(trainingId, userId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<TrainingDTO> updateTrainingEndpoint(@RequestBody @Valid TrainingDTO trainingDTO, @PathVariable Long trainingId, @PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.updateTraining(trainingDTO, trainingId, userId));
    }

    @GetMapping("/training/{userId}")
    public ResponseEntity<TrainingStatisticsDTO> getStatisticsForUserIdEndpoint(@PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.getStatisticsForUserId(userId));
    }

    @GetMapping("/training/history")
    public ResponseEntity<List<TrainingDTO>> getTrainingHistoryEndpoint() {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(trainingService.getTrainingsForUserByEmail(userEmail));
    }


}
package com.trainify.trainifybackend.training.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import jakarta.validation.constraints.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

public record TrainingDTO(


        Long id,
        Long userId,

        @NotNull
        ExerciseType exerciseType,


        @Min(1) int duration,
        @Min(1) int amount,
        @Min(1) int sleep,
        @Max(5) @Min(1) int mood, //nastroj po treningu 1 - bardzo zly, 5 - bardzo dobry

        String note,

        @PastOrPresent LocalDate date,
        @JsonInclude(JsonInclude.Include.NON_NULL) LocalDateTime createdAt,


       @Min(0) @Max(100) double intensityScore,

        String intensityScoreMessage



) {
}
package com.trainify.trainifybackend.training.dto;

public record TrainingStatisticsDTO(
        long totalTrainingsInWeek,
        long totalAmountInMonth,
        double averageMood,
        double averageSleep,
        double averageDuration

) {
}
package com.trainify.trainifybackend.training.model;

public enum ExerciseType {
    Pompki,
    Przysiady,
    Brzuszki,
    Plank,
    Wykroki,
    Skakanka,
    MartwyCiag,
    Wioslowanie,
    Podciaganie,
    Bieganie,
    Plywanie,
    Inne
}
package com.trainify.trainifybackend.training.model;


import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "trainings")
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Training {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date; // data treningu

    private LocalDateTime createdAt;// kiedy wpis zosta≈Ç dodany

    private ExerciseType exerciseType; // rodzaj ƒáwiczenia, np. ‚Äûpompki‚Äù
    private String note; // opcjonalna notatka

    private int amount; // liczba powt√≥rze≈Ñ
    private int mood; // 1‚Äì5 (1 - bardzo z≈Çy, 5 - bardzo dobry, nastroj po treningu)
    private int sleep; // liczba godzin snu

    private int duration; // czas w minutach cwiczenia

    private double intensityScore; // Wynik intensywnosci treningu 0 - 100
    private String intensityScoreMessage; // Komunikat jak intensywny trening byl

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;

}
package com.trainify.trainifybackend.training.repository;

import com.trainify.trainifybackend.training.model.Training;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TrainingRepository extends JpaRepository<Training, Long> {


    Optional<Training> findTrainingByIdAndUserAssigned_Id(Long trainingId, Long userId); // metoda do pobierania treningu po ID treningu i ID u≈ºytkownika

    List<Training> findAllByUserAssigned_Id(Long userId); // Pobieranie wszystkich trening√≥w danego u≈ºytkownika




}
package com.trainify.trainifybackend.training.service;

import com.trainify.trainifybackend.exception.TrainingForUserNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.repository.TrainingRepository;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import com.trainify.trainifybackend.user.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TrainingService {


    private final TrainingRepository trainingRepository;
    private final UserRepository userRepository;
    private final UserService userService;

    public TrainingDTO addTraining(TrainingDTO trainingDTO) {

        User user = userService.getUserById(trainingDTO.userId())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika z id " + trainingDTO.userId()));
        Training training = Training.builder()
                .exerciseType(trainingDTO.exerciseType())
                .duration(trainingDTO.duration())
                .amount(trainingDTO.amount())
                .sleep(trainingDTO.sleep())
                .mood(trainingDTO.mood())
                .note(trainingDTO.note())
                .date(trainingDTO.date())
                .createdAt(LocalDateTime.now())
                // Obecnie frontend przesy≈Ça createdAt. W praktyce lepiej generowaƒá go po stronie backendu:
                // .createdAt(LocalDateTime.now())  - > Zapobiega przypadkowym b≈Çƒôdom lub manipulacji czasem treningu z frontu.
                // Zapytaj brasia
                // 18.10.25 / 23:14 :D
                .userAssigned(user)
                .build();
        calculateTiS(training);
        Training savedTraining = trainingRepository.save(training);

        return new TrainingDTO(
                savedTraining.getId(),
                savedTraining.getUserAssigned().getId(),
                savedTraining.getExerciseType(),
                savedTraining.getDuration(),
                savedTraining.getAmount(),
                savedTraining.getSleep(),
                savedTraining.getMood(),
                savedTraining.getNote(),
                savedTraining.getDate(),
                savedTraining.getCreatedAt(),
                savedTraining.getIntensityScore(),
                savedTraining.getIntensityScoreMessage()
        );
    }


    public void deleteTraining(Long trainingId, Long userId) {
        Training training = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego u≈ºytkownika"
                ));
        trainingRepository.delete(training);

    }


    public TrainingDTO updateTraining(TrainingDTO trainingDTO, Long trainingId, Long userId) {
        Training existingTraining = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego u≈ºytkownika"
                ));

        Training updatedTraining = Training.builder()
                .id(existingTraining.getId()) // Zachowaj to samo ID
                .userAssigned(existingTraining.getUserAssigned()) // Zachowaj przypisanie u≈ºytkownika
                .exerciseType(trainingDTO.exerciseType())
                .duration(trainingDTO.duration())
                .amount(trainingDTO.amount())
                .sleep(trainingDTO.sleep())
                .mood(trainingDTO.mood())
                .note(trainingDTO.note())
                .date(trainingDTO.date())
                .createdAt(existingTraining.getCreatedAt()) // Zachowaj oryginalnƒÖ datƒô utworzenia
                .build();
        calculateTiS(updatedTraining);
        Training savedTraining = trainingRepository.save(updatedTraining);


        return new TrainingDTO(
                savedTraining.getId(),
                savedTraining.getUserAssigned().getId(),
                savedTraining.getExerciseType(),
                savedTraining.getDuration(),
                savedTraining.getAmount(),
                savedTraining.getSleep(),
                savedTraining.getMood(),
                savedTraining.getNote(),
                savedTraining.getDate(),
                savedTraining.getCreatedAt(),
                savedTraining.getIntensityScore(),
                savedTraining.getIntensityScoreMessage()
        );
    }


    public TrainingStatisticsDTO getStatisticsForUserId(Long userId) {
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(userId);

        if (trainings.isEmpty()) {
            return new TrainingStatisticsDTO(0, 0, 0.0, 0.0, 0.0);
        }

        LocalDate oneWeekAgo = LocalDate.now().minusWeeks(1);
        LocalDate oneMonthAgo = LocalDate.now().minusMonths(1);

        long totalTrainingsInWeek = trainings.stream()
                .filter(t -> t.getDate() != null && t.getDate().isAfter(oneWeekAgo))
                .count();
        long totalAmountInMonth = trainings.stream()
                .filter(t -> t.getDate() != null && t.getDate().isAfter(oneMonthAgo))
                .mapToInt(Training::getAmount)
                .sum();


        double averageMood = trainings.stream()
                .mapToInt(Training::getMood)
                .average()
                .orElse(0.0);
        double averageSleep = trainings.stream()
                .mapToInt(Training::getSleep)
                .average()
                .orElse(0.0);
        double averageDuration = trainings.stream()
                .mapToInt(Training::getDuration)
                .average()
                .orElse(0.0);

        return new TrainingStatisticsDTO(totalTrainingsInWeek, totalAmountInMonth, averageMood, averageSleep, averageDuration);

    }


    public List<TrainingDTO> getTrainingsForUserByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika po emailu " + email));
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(user.getId());

        return trainings.stream()
                .map(this::mapToTrainingDTO)
                .collect(Collectors.toList());
    }

    private TrainingDTO mapToTrainingDTO(Training training) {
        return new TrainingDTO(
                training.getId(),
                training.getUserAssigned().getId(),
                training.getExerciseType(),
                training.getDuration(),
                training.getAmount(),
                training.getSleep(),
                training.getMood(),
                training.getNote(),
                training.getDate(),
                training.getCreatedAt(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage()
        );
    }


    public void calculateTiS(Training training) {
        double TiS = (training.getAmount() * 2 + training.getDuration() * 0.5 + training.getMood() * 2) * ((double) training.getSleep() / 10);

        if (TiS < 0) TiS = 0;
        if (TiS > 100) TiS = 100;

        String feedback;
        if (TiS < 40) feedback = "Trening lekki";
        else if (TiS < 70) feedback = "Trening dobry";
        else feedback = "Trening bardzo dobry";

        training.setIntensityScore(TiS);
        training.setIntensityScoreMessage(feedback);
    }
}
package com.trainify.trainifybackend.user.controller;


import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RequiredArgsConstructor
@RestController
public class UserController {

    private final UserService userService;


    @PostMapping("/register")
    public ResponseEntity<UserRegisterLoginDTO> registerUserEndpoint(@RequestBody @Valid UserRegisterLoginDTO userRegisterLoginDTO) {
        return ResponseEntity.ok(userService.registerUser(userRegisterLoginDTO));
    }

    @PostMapping("/login")
    public ResponseEntity<UserRegisterLoginDTO> loginUserEndpoint(@RequestBody @Valid UserRegisterLoginDTO userLogin) {
        return ResponseEntity.ok(userService.loginUser(userLogin.email(), userLogin.password()));
    }
}

package com.trainify.trainifybackend.user.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;


public record UserRegisterLoginDTO(
        Long id,
        String username,
        @NotBlank
        String password,

        @Email
        String email,

        String jwtToken

) {
}
package com.trainify.trainifybackend.user.model;

import com.trainify.trainifybackend.training.model.Training;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "users")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;


    private String username;
    private String password;
    private String email;
    private LocalDateTime createdAt;


    @OneToMany(mappedBy = "userAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Training> trainings;
}
package com.trainify.trainifybackend.user.repository;

import com.trainify.trainifybackend.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User>findByEmail(String email); // metoda do znajdowania u≈ºytkownika po nazwie u≈ºytkownika lub emailu



    boolean existsByUsername(String username); // metoda do sprawdzania czy istnieje u≈ºytkownik o danej nazwie u≈ºytkownika
    boolean existsByEmail(String email); // metoda do sprawdzania czy istnieje u≈ºytkownik o danym emailu
}
package com.trainify.trainifybackend.user.service;

import com.trainify.trainifybackend.exception.EmailAlreadyExistsException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.exception.UsernameAlreadyExistsException;
import com.trainify.trainifybackend.exception.WrongPasswordException;
import com.trainify.trainifybackend.security.service.JwtService;
import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {


    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;


    public UserRegisterLoginDTO registerUser(UserRegisterLoginDTO userRegisterLoginDTO) {

        if (userRepository.existsByUsername(userRegisterLoginDTO.username())) {
            throw new UsernameAlreadyExistsException("Nazwa u≈ºytkownika jest ju≈º zajƒôta");
        }

        if (userRepository.existsByEmail(userRegisterLoginDTO.email())) {
            throw new EmailAlreadyExistsException("Email jest ju≈º zajƒôty");
        }


        User user = User.builder()
                .username(userRegisterLoginDTO.username())
                .email(userRegisterLoginDTO.email())
                .password(passwordEncoder.encode(userRegisterLoginDTO.password())) // hashowanie has≈Ça
                .createdAt(LocalDateTime.now())
                .build();
        User savedUser = userRepository.save(user);

        String jwtToken = jwtService.generateToken(
                new org.springframework.security.core.userdetails.User(
                        savedUser.getEmail(),
                        savedUser.getPassword(),
                        List.of()
                )
        );

        return new UserRegisterLoginDTO(user.getId(),savedUser.getUsername(), null, savedUser.getEmail(), jwtToken);

    }

    public UserRegisterLoginDTO loginUser(String email, String rawPassword) {
        try {
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(email, rawPassword)
            );
        } catch (AuthenticationException e) {
            throw new WrongPasswordException("Nieprawid≈Çowy email lub has≈Ço");
        }


        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));


        UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                List.of()
        );
        String jwtToken = jwtService.generateToken(userDetails);

        return new UserRegisterLoginDTO(user.getId(),user.getUsername(), null, user.getEmail(), jwtToken);
    }


    public Optional<User> getUserById(Long userId) {
        return userRepository.findById(userId);
    }


}
package com.trainify.trainifybackend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TrainifyBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(TrainifyBackendApplication.class, args);
	}

}
package com.trainify.trainifybackend.training.service;

public class TrainingServiceTest {
}
package com.trainify.trainifybackend.user.service;


import com.trainify.trainifybackend.exception.EmailAlreadyExistsException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.exception.UsernameAlreadyExistsException;
import com.trainify.trainifybackend.exception.WrongPasswordException;
import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class UserServiceTest {

    @InjectMocks
    private UserService userService; //InjectMocks dlatego ze testujesz prawdziwe zachowanie UserService

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;


    @Test
    void shouldRegisterUserSuccessfully() {

        // GIVEN
        UserRegisterLoginDTO userRegisterLoginDTO = new UserRegisterLoginDTO("Marcin", "haslo123", "supermail@example.com");

        when(userRepository.existsByUsername("Marcin")).thenReturn(false);
        when(userRepository.existsByEmail("supermail@example.com")).thenReturn(false);


        when(passwordEncoder.encode("haslo123")).thenReturn("hashedPassword");

        //Powyzej symulujesz czy uzytkownik "Marcin: z mailem "supermail@example.com" nie istnieje w bazie, symulujesz czy haslo zosta≈Ço zahashowane


        User savedUser = User.builder()
                .id(1L)
                .username("Marcin")
                .email("supermail@example.com")
                .password("hashedPassword")
                .build();


        when(userRepository.save(any(User.class))).thenReturn(savedUser);

        //WHEN
        UserRegisterLoginDTO result = userService.registerUser(userRegisterLoginDTO);


        //THEN
        assertEquals("Marcin", result.username());
        assertEquals("supermail@example.com", result.email());
        assertNull(result.password());

    }


    @Test
    void shouldThrowWhenUsernameAlreadyExists() {


        //GIVEN
        UserRegisterLoginDTO userRegisterLoginDTO = new UserRegisterLoginDTO("Marcin", null, null);

        when(userRepository.existsByUsername("Marcin")).thenReturn(true);

        //WHEN & THEN
        assertThrows(UsernameAlreadyExistsException.class, () -> userService.registerUser(userRegisterLoginDTO));


    }

    @Test
    void shouldThrowWhenEmailAlreadyExists() {

        //GIVEN
        UserRegisterLoginDTO userRegisterLoginDTO = new UserRegisterLoginDTO(null, null, "example@gmail.com");

        when(userRepository.existsByEmail("example@gmail.com")).thenReturn(true);

        assertThrows(EmailAlreadyExistsException.class, () -> userService.registerUser(userRegisterLoginDTO));

    }

    @Test
    void shouldLoginSuccessfully() {
        //GIVEN
        User user = User.builder()
                .id(1L)
                .username("Marcin")
                .email("example@gmail.com")
                .password("hashedPassword")
                .build();

        when(userRepository.findByEmail("example@gmail.com")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("haslo123", "hashedPassword")).thenReturn(true);


        UserRegisterLoginDTO result = userService.loginUser("example@gmail.com", "haslo123");


        assertEquals("example@gmail.com", result.email());
        assertNull(result.password());


    }

    @Test
    void shouldThrowWhenUserNotFound() {


        when(userRepository.findByEmail("example@gmail.com")).thenReturn(Optional.empty());

        assertThrows(UserNotFoundException.class, () -> userService.loginUser("example@gmail.com", "haslo123"));

    }


    @Test
    void shouldThrowWhenWrongPassword() {

        User user = User.builder()
                .id(1L)
                .username("Marcin")
                .email("example@gmail.com")
                .password("hashedPassword")
                .build();

        when(userRepository.findByEmail("example@gmail.com")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("wrongPassword", "hashedPassword")).thenReturn(false);


        assertThrows(WrongPasswordException.class, () -> userService.loginUser("example@gmail.com", "wrongPassword"));


    }



}
package com.trainify.trainifybackend;

import com.trainify.trainifybackend.user.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TrainifyBackendApplicationTests {

    @Autowired
    private UserService service;


	@Test
	void contextLoads() {
	}

}
